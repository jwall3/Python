#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Oct 17 20:02:13 2019
@author: joe

"""
'''
The below script, so far, creates a spiral of points on a sphere. Plots the points in 3d then attempts to create a pdb file for
opening with Pymol/VMD veiwing of the points. The points will be the points where the cys from each peptide is placed.
#SPHERICAL FROM: Kogan, Jonathan (2017) "A New Computationally Efficient
#Method for Spacing n Points on a Sphere," Rose-Hulman Undergraduate Mathematics
#Journal: Vol. 18 : Iss. 2 , Article 5.
#Available at: https://scholar.rose-hulman.edu/rhumj/vol18/iss2/5
'''
###############################################################################
###############################################################################

import math

#Creates the spherical lines
def spherical_coordinate(x,y):
    return [math.cos(x) * math.cos(y),
            math.sin(x) * math.cos(y), math.sin(y)]

#Creates the actual N points    
def NX(n, x):
    pts=[]
    start = (-1. + 1. / (n - 1.) )
    increment = (2. - 2. / (n -1.)) / (n -1.)
    for j in range(0, n):
        s = start + j * increment
        pts.append(
        spherical_coordinate(
        s * x, math.pi / 2. *
        math.copysign(1, s) *
        (1. - math.sqrt(1. -abs(s)))
        ))
       
    return pts

#Generates complete set of points in a list of lists
def generate_points(n):
    return NX(n, 0.1 + 1.2 * n)


#Split the generated points into XYZ
def xyz(n):
    global POINTS
    POINTS=[]
    c = 0
   
    while c < 3:
        for v in genplot:
            POINTS.append(genplot[c][n])
            c+=1
           
    return(POINTS)
    x = xyz(0)
    return(x)
    y = xyz(1)
    return(y)
    z = xyz(2)
    return(z)


#Define the xyz points to move cys to.
def points():

    FileName = "TEST \n"
    FileLen = len(x)
    
    #xd = max(x)
    #yd = max(y)
    #zd = max(z)
    
    c=0
    o = 0
    with open ("testpriems.gro", "a") as f:
        f.write(FileName)
        f.write("%5s \n" %(FileLen))
        for v in x:
            print(v)  
            i = (genplot[c])
            xa = ((i[0]/2)*size)
            ya = ((i[1]/2)*size)
            za = ((i[2]/2)*size)
            q = c+1
            p=(q)  
            f.write("%5d%-5s%5s%5d%8.3f%8.3f%8.3f \n" % (p, "AU2", "AUB", p, xa, ya, za))
            c+=1  
    global linenum
    linenum = c
    print(linenum)
#Defining theta for rotation around x,y z.
def theta():            

    
    c=0
    global thetasxy
    global thetaszx
    global thetasyz
    thetasxy = []
    thetaszx = []
    thetasyz = []
    
    for p in genplot:
            i = (genplot[c])
            xa = ((i[0]/2)*size)
            ya = ((i[1]/2)*size)
            za = ((i[2]/2)*size)
            thetaxy = math.atan(xa/ya)
            thetasxy.append(thetaxy)
            thetazx = math.atan(za/xa)
            thetaszx.append(thetazx)
            thetayz = math.atan(ya/za)
            thetasyz.append(thetaxy)
            c+=1
    global thetas      
    thetas = (thetasxy, thetaszx, thetasyz)        
    
    print("THIS IS THETAS",thetasxy)



###############################################################################
#Works out how many lines = atoms in Peptide.gro and saves as Leng.
#Opens peptide.gro as pfn.
def pep_len(pfn):
    global leng
    with open(pfn) as f:
        for leng, l in enumerate(f):
            pass

    print(leng)

#A function to open a file = pfn. Split each column into a list with length leng
# depending on value of column (0-6 in pfn), it is saved to "variable"
def fs(leng,column,pfn):
    global variable
    variable = []
    f = open (pfn, "r")

    for line in f:
        data = f.readlines()

    variable = []
    value = 0
    while value < leng:
        if value>0:
            dx = data[value].split()
            variable.append(dx[column])
            value+=1
        else:
         value+=1
    #print(variable)
    return(variable)


#Split uses the func fn, to open pfn and save each column to a list named Varx, 
# where x = column num. These are then replaced with actual names and added to
# a dictionary of lists with the name as the key.
def split(leng):
    pfn = "peptide.gro"
    pep_len(pfn)    
    
    peptide_gro = {}
    
    v = 0
    while v<6:
        peptide_gro["var"+str(v)] = fs(leng,v,pfn)
        v+=1
    
    
    global Pep_Name
    Pep_Name = (peptide_gro['var0'])
    global Atom_Name
    Atom_Name = (peptide_gro['var1'])
    global Atom_Number
    Atom_Number = (peptide_gro['var2'])
    global X_Coor
    X_Coor = (peptide_gro['var3'])
    global Y_Coor
    Y_Coor = (peptide_gro['var4'])
    global Z_Coor
    Z_Coor = (peptide_gro['var5'])
    
    
def add_pep():
    with open ("testpriems.gro", "a") as f:
        sp=(len(X_Coor))
        c = 0
        while c < sp: 
        #for v in X_Coor:
            PN = (Pep_Name[c])
            ANa = (Atom_Name[c])
            ANu = (Atom_Number[c])
            x = float(X_Coor[c])
            y = float(Y_Coor[c])            
            z = float(Z_Coor[c])            
            print(PN)
            print(ANa)
            print(ANu)
            print(x,y,z)
            
            
            
            f.write("%8s%7s%5d%8.3f%8.3f%8.3f \n" % (PN, ANa, c,x,y,z))   
            c +=1
   
#f.write("%5d%-5s%5s%5d%8.3f%8.3f%8.3f%8.4f%8.4f%8.4f \n" % (p, Pep_Name, Atom_Name, Atom_Number, X_Coor, Y_Coor, Z_Coor))
#c+=1  
##############################################################################

#RUNNING THE ABOVE
size = 14.25
d = 2.31


(spherical_coordinate(1,1))
(NX(900,1))
genplot = (generate_points(900))
x = xyz(0)
y = xyz(1)
z = xyz(2)
points()
theta()

split(302)
add_pep()
pep_len("peptide.gro")

###############################################################################

print ("points....",genplot[1])

xfinal = []
yfinal = []
zfinal = []

c1 = 0
for n in genplot:
    c2 = 0
    for line in "peptide.gro":
        split(302)

        xold = float(X_Coor[c])
        yold = float(Y_Coor[c])
        zold = float(Z_Coor[c])
    
    
    #Rotate around z
        xnew = (xold*math.cos(thetasxy[c]))-(yold*math.sin(thetasxy[c]))
        ynew = (xold*math.sin(thetasxy[c]))+(yold*math.cos(thetasxy[c]))
        znew = zold
        
        xold=xnew
        yold=ynew
        zold=znew
    #Rotate around y
        xnew = (xold*math.cos(thetaszx[c]))+(zold*math.sin(thetaszx[c]))
        znew = (zold*math.cos(thetaszx[c]))-(xold*math.sin(thetaszx[c]))
        ynew = yold
        
        xold=xnew
        yold=ynew
        zold=znew
    #Rotate around x
        ynew = (yold*math.cos(thetasyz[c]))-(zold*math.sin(thetasyz[c]))
        znew = (yold*math.sin(thetasyz[c]))+(zold*math.cos(thetasyz[c]))
        xnew = xold
        
        
    c2+=1
c1+=1




